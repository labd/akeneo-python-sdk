# coding: utf-8

"""
    Akeneo PIM REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import annotations
from inspect import getfullargspec
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, validator
from openapi_client.models.attributes_embedded_items_inner_all_of_labels import AttributesEmbeddedItemsInnerAllOfLabels

class GetAssetFamiliesCodeAttributes200ResponseInner(BaseModel):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """
    code: StrictStr = Field(..., description="Attribute code")
    labels: Optional[AttributesEmbeddedItemsInnerAllOfLabels] = None
    type: StrictStr = Field(..., description="Attribute type. See <a href='/concepts/asset-manager.html#asset-attribute'>type</a> section for more details.")
    value_per_locale: Optional[StrictBool] = Field(False, description="Whether the attribute is localizable, i.e. can have one value by locale")
    value_per_channel: Optional[StrictBool] = Field(False, description="Whether the attribute is scopable, i.e. can have one value by channel")
    is_required_for_completeness: Optional[StrictBool] = Field(False, description="Whether the attribute should be part of the record's completeness calculation")
    is_read_only: Optional[StrictBool] = Field(False, description="Whether the attribute should be in read only mode only in the UI, but you can still update it with the API")
    max_characters: Optional[StrictInt] = Field(None, description="Maximum number of characters allowed for the value of the attribute when the attribute type is `text`")
    is_textarea: Optional[StrictBool] = Field(False, description="Whether the UI should display a text area instead of a simple field when the attribute type is `text`")
    is_rich_text_editor: Optional[StrictBool] = Field(None, description="Whether the UI should display a rich text editor instead of a simple text area when the attribute type is `text`")
    validation_rule: Optional[StrictStr] = Field('none', description="Validation rule type used to validate the attribute value when the attribute type is `text`")
    validation_regexp: Optional[StrictStr] = Field('null', description="Regexp expression used to validate the attribute value when the attribute type is `text`")
    allowed_extensions: Optional[List[StrictStr]] = Field(None, description="Extensions allowed when the attribute type is `media_file`")
    max_file_size: Optional[StrictStr] = Field('null', description="Max file size in MB when the attribute type is `media_file`")
    decimals_allowed: Optional[StrictBool] = Field(False, description="Whether decimals are allowed when the attribute type is `number`")
    min_value: Optional[StrictStr] = Field('null', description="Minimum value allowed when the attribute type is `number`")
    max_value: Optional[StrictStr] = Field('null', description="Maximum value allowed when the attribute type is `number`")
    media_type: StrictStr = Field(..., description="For the `media_link` attribute type, it is the type of the media behind the url, to allow its preview in the PIM. For the `media_file` attribute type, it is the type of the file.")
    prefix: Optional[StrictStr] = Field('null', description="Prefix of the `media_link` attribute type. The common url root that prefixes the link to the media")
    suffix: Optional[StrictStr] = Field('null', description="Suffix of the `media_link` attribute type. The common url suffix for the media")
    __properties = ["code", "labels", "type", "value_per_locale", "value_per_channel", "is_required_for_completeness", "is_read_only", "max_characters", "is_textarea", "is_rich_text_editor", "validation_rule", "validation_regexp", "allowed_extensions", "max_file_size", "decimals_allowed", "min_value", "max_value", "media_type", "prefix", "suffix"]

    @validator('type')
    def type_validate_enum(cls, v):
        if v not in ('text', 'media_link', 'number', 'media_file', 'single_option', 'multiple_options', 'reference_entity_single_link', 'reference_entity_multiple_links', 'boolean'):
            raise ValueError("must validate the enum values ('text', 'media_link', 'number', 'media_file', 'single_option', 'multiple_options', 'reference_entity_single_link', 'reference_entity_multiple_links', 'boolean')")
        return v

    @validator('validation_rule')
    def validation_rule_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('email', 'url', 'regexp', 'none'):
            raise ValueError("must validate the enum values ('email', 'url', 'regexp', 'none')")
        return v

    @validator('media_type')
    def media_type_validate_enum(cls, v):
        if v not in ('image', 'pdf', 'youtube', 'vimeo', 'other'):
            raise ValueError("must validate the enum values ('image', 'pdf', 'youtube', 'vimeo', 'other')")
        return v

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> GetAssetFamiliesCodeAttributes200ResponseInner:
        """Create an instance of GetAssetFamiliesCodeAttributes200ResponseInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of labels
        if self.labels:
            _dict['labels'] = self.labels.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> GetAssetFamiliesCodeAttributes200ResponseInner:
        """Create an instance of GetAssetFamiliesCodeAttributes200ResponseInner from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return GetAssetFamiliesCodeAttributes200ResponseInner.parse_obj(obj)

        _obj = GetAssetFamiliesCodeAttributes200ResponseInner.parse_obj({
            "code": obj.get("code"),
            "labels": AttributesEmbeddedItemsInnerAllOfLabels.from_dict(obj.get("labels")) if obj.get("labels") is not None else None,
            "type": obj.get("type"),
            "value_per_locale": obj.get("value_per_locale") if obj.get("value_per_locale") is not None else False,
            "value_per_channel": obj.get("value_per_channel") if obj.get("value_per_channel") is not None else False,
            "is_required_for_completeness": obj.get("is_required_for_completeness") if obj.get("is_required_for_completeness") is not None else False,
            "is_read_only": obj.get("is_read_only") if obj.get("is_read_only") is not None else False,
            "max_characters": obj.get("max_characters"),
            "is_textarea": obj.get("is_textarea") if obj.get("is_textarea") is not None else False,
            "is_rich_text_editor": obj.get("is_rich_text_editor"),
            "validation_rule": obj.get("validation_rule") if obj.get("validation_rule") is not None else 'none',
            "validation_regexp": obj.get("validation_regexp") if obj.get("validation_regexp") is not None else 'null',
            "allowed_extensions": obj.get("allowed_extensions"),
            "max_file_size": obj.get("max_file_size") if obj.get("max_file_size") is not None else 'null',
            "decimals_allowed": obj.get("decimals_allowed") if obj.get("decimals_allowed") is not None else False,
            "min_value": obj.get("min_value") if obj.get("min_value") is not None else 'null',
            "max_value": obj.get("max_value") if obj.get("max_value") is not None else 'null',
            "media_type": obj.get("media_type"),
            "prefix": obj.get("prefix") if obj.get("prefix") is not None else 'null',
            "suffix": obj.get("suffix") if obj.get("suffix") is not None else 'null'
        })
        return _obj

