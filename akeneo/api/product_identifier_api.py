# coding: utf-8

"""
    Akeneo PIM REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, conint

from typing import Optional

from akeneo.models.patch_products200_response import PatchProducts200Response
from akeneo.models.patch_products_request import PatchProductsRequest
from akeneo.models.products import Products
from akeneo.models.products_embedded_items_inner_all_of1 import ProductsEmbeddedItemsInnerAllOf1

from akeneo.api_client import ApiClient
from akeneo.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ProductIdentifierApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def delete_products_code(self, code : Annotated[StrictStr, Field(..., description="Code of the resource")], **kwargs) -> None:  # noqa: E501
        """Delete a product  # noqa: E501

        This endpoint allows you to delete a given product. In the Enterprise Edition, since the 2.0, permissions based on your user groups are applied to the product you try to delete.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_products_code(code, async_req=True)
        >>> result = thread.get()

        :param code: Code of the resource (required)
        :type code: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_products_code_with_http_info(code, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_products_code_with_http_info(self, code : Annotated[StrictStr, Field(..., description="Code of the resource")], **kwargs):  # noqa: E501
        """Delete a product  # noqa: E501

        This endpoint allows you to delete a given product. In the Enterprise Edition, since the 2.0, permissions based on your user groups are applied to the product you try to delete.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_products_code_with_http_info(code, async_req=True)
        >>> result = thread.get()

        :param code: Code of the resource (required)
        :type code: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'code'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_products_code" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['code']:
            _path_params['code'] = _params['code']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'code', 'message'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/rest/v1/products/{code}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_draft_code(self, code : Annotated[StrictStr, Field(..., description="Code of the resource")], **kwargs) -> ProductsEmbeddedItemsInnerAllOf1:  # noqa: E501
        """Get a draft  # noqa: E501

        This endpoint allows you to get the information about a given draft.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_draft_code(code, async_req=True)
        >>> result = thread.get()

        :param code: Code of the resource (required)
        :type code: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProductsEmbeddedItemsInnerAllOf1
        """
        kwargs['_return_http_data_only'] = True
        return self.get_draft_code_with_http_info(code, **kwargs)  # noqa: E501

    @validate_arguments
    def get_draft_code_with_http_info(self, code : Annotated[StrictStr, Field(..., description="Code of the resource")], **kwargs):  # noqa: E501
        """Get a draft  # noqa: E501

        This endpoint allows you to get the information about a given draft.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_draft_code_with_http_info(code, async_req=True)
        >>> result = thread.get()

        :param code: Code of the resource (required)
        :type code: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProductsEmbeddedItemsInnerAllOf1, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'code'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_draft_code" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['code']:
            _path_params['code'] = _params['code']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'code', 'message'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ProductsEmbeddedItemsInnerAllOf1",
            '401': "GetProducts401Response",
            '403': "GetProducts401Response",
            '404': "GetProducts401Response",
            '406': "GetProducts401Response",
        }

        return self.api_client.call_api(
            '/api/rest/v1/products/{code}/draft', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_products(self, search : Annotated[Optional[StrictStr], Field(description="Filter products, for more details see the <a href=\"/documentation/filter.html\">Filters</a> section")] = None, scope : Annotated[Optional[StrictStr], Field(description="Filter product values to return scopable attributes for the given channel as well as the non localizable/non scopable attributes, for more details see the <a href=\"/documentation/filter.html#via-channel\">Filter product values via channel</a> section")] = None, locales : Annotated[Optional[StrictStr], Field(description="Filter product values to return localizable attributes for the given locales as well as the non localizable/non scopable attributes, for more details see the <a href=\"/documentation/filter.html#via-locale\">Filter product values via locale</a> section")] = None, attributes : Annotated[Optional[StrictStr], Field(description="Filter product values to only return those concerning the given attributes, for more details see the <a href=\"/documentation/filter.html#filter-product-values\">Filter on product values</a> section")] = None, pagination_type : Annotated[Optional[StrictStr], Field(description="Pagination method type, see <a href=\"/documentation/pagination.html\">Pagination</a> section")] = None, page : Annotated[Optional[StrictInt], Field(description="Number of the page to retrieve when using the `page` pagination method type. <strong>Should never be set manually</strong>, see <a href=\"/documentation/pagination.html#pagination\">Pagination</a> section")] = None, search_after : Annotated[Optional[StrictStr], Field(description="Cursor when using the `search_after` pagination method type. <strong>Should never be set manually</strong>, see <a href=\"/documentation/pagination.html\">Pagination</a> section")] = None, limit : Annotated[Optional[conint(strict=True, le=100, ge=1)], Field(description="Number of results by page, see <a href=\"/documentation/pagination.html\">Pagination</a> section")] = None, with_count : Annotated[Optional[StrictBool], Field(description="Return the count of items in the response. Be carefull with that, on a big catalog, it can decrease performance in a significative way")] = None, with_attribute_options : Annotated[Optional[StrictBool], Field(description="Return labels of attribute options in the response. (Only available since the 5.0 version)")] = None, with_quality_scores : Annotated[Optional[StrictBool], Field(description="Return product quality scores in the response. (Only available since the 5.0 version)")] = None, with_completenesses : Annotated[Optional[StrictBool], Field(description="Return product completenesses in the response. (Only available since the 6.0 version)")] = None, **kwargs) -> Products:  # noqa: E501
        """Get list of products  # noqa: E501

        This endpoint allows you to get a list of products. Products are paginated and they can be filtered. In the Enterprise Edition, since the 2.0, permissions based on your user groups are applied to the set of products you request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_products(search, scope, locales, attributes, pagination_type, page, search_after, limit, with_count, with_attribute_options, with_quality_scores, with_completenesses, async_req=True)
        >>> result = thread.get()

        :param search: Filter products, for more details see the <a href=\"/documentation/filter.html\">Filters</a> section
        :type search: str
        :param scope: Filter product values to return scopable attributes for the given channel as well as the non localizable/non scopable attributes, for more details see the <a href=\"/documentation/filter.html#via-channel\">Filter product values via channel</a> section
        :type scope: str
        :param locales: Filter product values to return localizable attributes for the given locales as well as the non localizable/non scopable attributes, for more details see the <a href=\"/documentation/filter.html#via-locale\">Filter product values via locale</a> section
        :type locales: str
        :param attributes: Filter product values to only return those concerning the given attributes, for more details see the <a href=\"/documentation/filter.html#filter-product-values\">Filter on product values</a> section
        :type attributes: str
        :param pagination_type: Pagination method type, see <a href=\"/documentation/pagination.html\">Pagination</a> section
        :type pagination_type: str
        :param page: Number of the page to retrieve when using the `page` pagination method type. <strong>Should never be set manually</strong>, see <a href=\"/documentation/pagination.html#pagination\">Pagination</a> section
        :type page: int
        :param search_after: Cursor when using the `search_after` pagination method type. <strong>Should never be set manually</strong>, see <a href=\"/documentation/pagination.html\">Pagination</a> section
        :type search_after: str
        :param limit: Number of results by page, see <a href=\"/documentation/pagination.html\">Pagination</a> section
        :type limit: int
        :param with_count: Return the count of items in the response. Be carefull with that, on a big catalog, it can decrease performance in a significative way
        :type with_count: bool
        :param with_attribute_options: Return labels of attribute options in the response. (Only available since the 5.0 version)
        :type with_attribute_options: bool
        :param with_quality_scores: Return product quality scores in the response. (Only available since the 5.0 version)
        :type with_quality_scores: bool
        :param with_completenesses: Return product completenesses in the response. (Only available since the 6.0 version)
        :type with_completenesses: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Products
        """
        kwargs['_return_http_data_only'] = True
        return self.get_products_with_http_info(search, scope, locales, attributes, pagination_type, page, search_after, limit, with_count, with_attribute_options, with_quality_scores, with_completenesses, **kwargs)  # noqa: E501

    @validate_arguments
    def get_products_with_http_info(self, search : Annotated[Optional[StrictStr], Field(description="Filter products, for more details see the <a href=\"/documentation/filter.html\">Filters</a> section")] = None, scope : Annotated[Optional[StrictStr], Field(description="Filter product values to return scopable attributes for the given channel as well as the non localizable/non scopable attributes, for more details see the <a href=\"/documentation/filter.html#via-channel\">Filter product values via channel</a> section")] = None, locales : Annotated[Optional[StrictStr], Field(description="Filter product values to return localizable attributes for the given locales as well as the non localizable/non scopable attributes, for more details see the <a href=\"/documentation/filter.html#via-locale\">Filter product values via locale</a> section")] = None, attributes : Annotated[Optional[StrictStr], Field(description="Filter product values to only return those concerning the given attributes, for more details see the <a href=\"/documentation/filter.html#filter-product-values\">Filter on product values</a> section")] = None, pagination_type : Annotated[Optional[StrictStr], Field(description="Pagination method type, see <a href=\"/documentation/pagination.html\">Pagination</a> section")] = None, page : Annotated[Optional[StrictInt], Field(description="Number of the page to retrieve when using the `page` pagination method type. <strong>Should never be set manually</strong>, see <a href=\"/documentation/pagination.html#pagination\">Pagination</a> section")] = None, search_after : Annotated[Optional[StrictStr], Field(description="Cursor when using the `search_after` pagination method type. <strong>Should never be set manually</strong>, see <a href=\"/documentation/pagination.html\">Pagination</a> section")] = None, limit : Annotated[Optional[conint(strict=True, le=100, ge=1)], Field(description="Number of results by page, see <a href=\"/documentation/pagination.html\">Pagination</a> section")] = None, with_count : Annotated[Optional[StrictBool], Field(description="Return the count of items in the response. Be carefull with that, on a big catalog, it can decrease performance in a significative way")] = None, with_attribute_options : Annotated[Optional[StrictBool], Field(description="Return labels of attribute options in the response. (Only available since the 5.0 version)")] = None, with_quality_scores : Annotated[Optional[StrictBool], Field(description="Return product quality scores in the response. (Only available since the 5.0 version)")] = None, with_completenesses : Annotated[Optional[StrictBool], Field(description="Return product completenesses in the response. (Only available since the 6.0 version)")] = None, **kwargs):  # noqa: E501
        """Get list of products  # noqa: E501

        This endpoint allows you to get a list of products. Products are paginated and they can be filtered. In the Enterprise Edition, since the 2.0, permissions based on your user groups are applied to the set of products you request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_products_with_http_info(search, scope, locales, attributes, pagination_type, page, search_after, limit, with_count, with_attribute_options, with_quality_scores, with_completenesses, async_req=True)
        >>> result = thread.get()

        :param search: Filter products, for more details see the <a href=\"/documentation/filter.html\">Filters</a> section
        :type search: str
        :param scope: Filter product values to return scopable attributes for the given channel as well as the non localizable/non scopable attributes, for more details see the <a href=\"/documentation/filter.html#via-channel\">Filter product values via channel</a> section
        :type scope: str
        :param locales: Filter product values to return localizable attributes for the given locales as well as the non localizable/non scopable attributes, for more details see the <a href=\"/documentation/filter.html#via-locale\">Filter product values via locale</a> section
        :type locales: str
        :param attributes: Filter product values to only return those concerning the given attributes, for more details see the <a href=\"/documentation/filter.html#filter-product-values\">Filter on product values</a> section
        :type attributes: str
        :param pagination_type: Pagination method type, see <a href=\"/documentation/pagination.html\">Pagination</a> section
        :type pagination_type: str
        :param page: Number of the page to retrieve when using the `page` pagination method type. <strong>Should never be set manually</strong>, see <a href=\"/documentation/pagination.html#pagination\">Pagination</a> section
        :type page: int
        :param search_after: Cursor when using the `search_after` pagination method type. <strong>Should never be set manually</strong>, see <a href=\"/documentation/pagination.html\">Pagination</a> section
        :type search_after: str
        :param limit: Number of results by page, see <a href=\"/documentation/pagination.html\">Pagination</a> section
        :type limit: int
        :param with_count: Return the count of items in the response. Be carefull with that, on a big catalog, it can decrease performance in a significative way
        :type with_count: bool
        :param with_attribute_options: Return labels of attribute options in the response. (Only available since the 5.0 version)
        :type with_attribute_options: bool
        :param with_quality_scores: Return product quality scores in the response. (Only available since the 5.0 version)
        :type with_quality_scores: bool
        :param with_completenesses: Return product completenesses in the response. (Only available since the 6.0 version)
        :type with_completenesses: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Products, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'search',
            'scope',
            'locales',
            'attributes',
            'pagination_type',
            'page',
            'search_after',
            'limit',
            'with_count',
            'with_attribute_options',
            'with_quality_scores',
            'with_completenesses'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_products" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))
        if _params.get('scope') is not None:  # noqa: E501
            _query_params.append(('scope', _params['scope']))
        if _params.get('locales') is not None:  # noqa: E501
            _query_params.append(('locales', _params['locales']))
        if _params.get('attributes') is not None:  # noqa: E501
            _query_params.append(('attributes', _params['attributes']))
        if _params.get('pagination_type') is not None:  # noqa: E501
            _query_params.append(('pagination_type', _params['pagination_type']))
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))
        if _params.get('search_after') is not None:  # noqa: E501
            _query_params.append(('search_after', _params['search_after']))
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))
        if _params.get('with_count') is not None:  # noqa: E501
            _query_params.append(('with_count', _params['with_count']))
        if _params.get('with_attribute_options') is not None:  # noqa: E501
            _query_params.append(('with_attribute_options', _params['with_attribute_options']))
        if _params.get('with_quality_scores') is not None:  # noqa: E501
            _query_params.append(('with_quality_scores', _params['with_quality_scores']))
        if _params.get('with_completenesses') is not None:  # noqa: E501
            _query_params.append(('with_completenesses', _params['with_completenesses']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'code', 'message', '_links'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Products",
            '401': "GetProducts401Response",
            '403': "GetProducts401Response",
            '406': "GetProducts401Response",
            '422': "GetProducts401Response",
        }

        return self.api_client.call_api(
            '/api/rest/v1/products', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_products_code(self, code : Annotated[StrictStr, Field(..., description="Code of the resource")], with_attribute_options : Annotated[Optional[StrictBool], Field(description="Return labels of attribute options in the response. (Only available since the 5.0 version)")] = None, with_quality_scores : Annotated[Optional[StrictBool], Field(description="Return product quality scores in the response. (Only available since the 5.0 version)")] = None, with_completenesses : Annotated[Optional[StrictBool], Field(description="Return product completenesses in the response. (Only available since the 6.0 version)")] = None, **kwargs) -> ProductsEmbeddedItemsInnerAllOf1:  # noqa: E501
        """Get a product  # noqa: E501

        This endpoint allows you to get the information about a given product. In the Entreprise Edition, since the v2.0, permissions based on your user groups are applied to the product you request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_products_code(code, with_attribute_options, with_quality_scores, with_completenesses, async_req=True)
        >>> result = thread.get()

        :param code: Code of the resource (required)
        :type code: str
        :param with_attribute_options: Return labels of attribute options in the response. (Only available since the 5.0 version)
        :type with_attribute_options: bool
        :param with_quality_scores: Return product quality scores in the response. (Only available since the 5.0 version)
        :type with_quality_scores: bool
        :param with_completenesses: Return product completenesses in the response. (Only available since the 6.0 version)
        :type with_completenesses: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProductsEmbeddedItemsInnerAllOf1
        """
        kwargs['_return_http_data_only'] = True
        return self.get_products_code_with_http_info(code, with_attribute_options, with_quality_scores, with_completenesses, **kwargs)  # noqa: E501

    @validate_arguments
    def get_products_code_with_http_info(self, code : Annotated[StrictStr, Field(..., description="Code of the resource")], with_attribute_options : Annotated[Optional[StrictBool], Field(description="Return labels of attribute options in the response. (Only available since the 5.0 version)")] = None, with_quality_scores : Annotated[Optional[StrictBool], Field(description="Return product quality scores in the response. (Only available since the 5.0 version)")] = None, with_completenesses : Annotated[Optional[StrictBool], Field(description="Return product completenesses in the response. (Only available since the 6.0 version)")] = None, **kwargs):  # noqa: E501
        """Get a product  # noqa: E501

        This endpoint allows you to get the information about a given product. In the Entreprise Edition, since the v2.0, permissions based on your user groups are applied to the product you request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_products_code_with_http_info(code, with_attribute_options, with_quality_scores, with_completenesses, async_req=True)
        >>> result = thread.get()

        :param code: Code of the resource (required)
        :type code: str
        :param with_attribute_options: Return labels of attribute options in the response. (Only available since the 5.0 version)
        :type with_attribute_options: bool
        :param with_quality_scores: Return product quality scores in the response. (Only available since the 5.0 version)
        :type with_quality_scores: bool
        :param with_completenesses: Return product completenesses in the response. (Only available since the 6.0 version)
        :type with_completenesses: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProductsEmbeddedItemsInnerAllOf1, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'code',
            'with_attribute_options',
            'with_quality_scores',
            'with_completenesses'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_products_code" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['code']:
            _path_params['code'] = _params['code']

        # process the query parameters
        _query_params = []
        if _params.get('with_attribute_options') is not None:  # noqa: E501
            _query_params.append(('with_attribute_options', _params['with_attribute_options']))
        if _params.get('with_quality_scores') is not None:  # noqa: E501
            _query_params.append(('with_quality_scores', _params['with_quality_scores']))
        if _params.get('with_completenesses') is not None:  # noqa: E501
            _query_params.append(('with_completenesses', _params['with_completenesses']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'code', 'message'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ProductsEmbeddedItemsInnerAllOf1",
            '401': "GetProducts401Response",
            '403': "GetProducts401Response",
            '404': "GetProducts401Response",
            '406': "GetProducts401Response",
        }

        return self.api_client.call_api(
            '/api/rest/v1/products/{code}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def patch_products(self, body : Optional[PatchProductsRequest] = None, **kwargs) -> PatchProducts200Response:  # noqa: E501
        """Update/create several products  # noqa: E501

        This endpoint allows you to update and/or create several products at once. Learn more about <a href=\"/documentation/update.html#update-behavior\">Update behavior</a>. Note that if no product exists for the given identifier, it creates it. In the Enterprise Edition, since the v2.0, permissions based on your user groups are applied to the products you try to update. It may result in the creation of drafts if you only have edit rights through the product's categories.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_products(body, async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: PatchProductsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PatchProducts200Response
        """
        kwargs['_return_http_data_only'] = True
        return self.patch_products_with_http_info(body, **kwargs)  # noqa: E501

    @validate_arguments
    def patch_products_with_http_info(self, body : Optional[PatchProductsRequest] = None, **kwargs):  # noqa: E501
        """Update/create several products  # noqa: E501

        This endpoint allows you to update and/or create several products at once. Learn more about <a href=\"/documentation/update.html#update-behavior\">Update behavior</a>. Note that if no product exists for the given identifier, it creates it. In the Enterprise Edition, since the v2.0, permissions based on your user groups are applied to the products you try to update. It may result in the creation of drafts if you only have edit rights through the product's categories.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_products_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: PatchProductsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PatchProducts200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_products" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['body']:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'x-example-1', 'x-example-2', 'x-example-3', 'code', 'message'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "PatchProducts200Response",
            '401': "GetProducts401Response",
            '403': "GetProducts401Response",
            '413': "GetProducts401Response",
            '415': "GetProducts401Response",
        }

        return self.api_client.call_api(
            '/api/rest/v1/products', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def patch_products_code(self, code : Annotated[StrictStr, Field(..., description="Code of the resource")], body : ProductsEmbeddedItemsInnerAllOf1, **kwargs) -> None:  # noqa: E501
        """Update/create a product  # noqa: E501

        This endpoint allows you to update a given product. Learn more about <a href=\"/documentation/update.html#update-behavior\">Update behavior</a>. Note that if no product exists for the given identifier, it creates it. In the Entreprise Edition, since the v2.0, permissions based on your user groups are applied to the product you try to update. It may result in the creation of a draft if you only have edit rights through the product's categories.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_products_code(code, body, async_req=True)
        >>> result = thread.get()

        :param code: Code of the resource (required)
        :type code: str
        :param body: (required)
        :type body: ProductsEmbeddedItemsInnerAllOf1
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.patch_products_code_with_http_info(code, body, **kwargs)  # noqa: E501

    @validate_arguments
    def patch_products_code_with_http_info(self, code : Annotated[StrictStr, Field(..., description="Code of the resource")], body : ProductsEmbeddedItemsInnerAllOf1, **kwargs):  # noqa: E501
        """Update/create a product  # noqa: E501

        This endpoint allows you to update a given product. Learn more about <a href=\"/documentation/update.html#update-behavior\">Update behavior</a>. Note that if no product exists for the given identifier, it creates it. In the Entreprise Edition, since the v2.0, permissions based on your user groups are applied to the product you try to update. It may result in the creation of a draft if you only have edit rights through the product's categories.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_products_code_with_http_info(code, body, async_req=True)
        >>> result = thread.get()

        :param code: Code of the resource (required)
        :type code: str
        :param body: (required)
        :type body: ProductsEmbeddedItemsInnerAllOf1
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'code',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_products_code" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['code']:
            _path_params['code'] = _params['code']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['body']:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'code', 'message', '_links'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/rest/v1/products/{code}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def post_products(self, body : Optional[ProductsEmbeddedItemsInnerAllOf1] = None, **kwargs) -> None:  # noqa: E501
        """Create a new product  # noqa: E501

        This endpoint allows you to create a new product. In the Enterprise Edition, since the v2.0, permissions based on your user groups are applied to the product you try to create.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_products(body, async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: ProductsEmbeddedItemsInnerAllOf1
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.post_products_with_http_info(body, **kwargs)  # noqa: E501

    @validate_arguments
    def post_products_with_http_info(self, body : Optional[ProductsEmbeddedItemsInnerAllOf1] = None, **kwargs):  # noqa: E501
        """Create a new product  # noqa: E501

        This endpoint allows you to create a new product. In the Enterprise Edition, since the v2.0, permissions based on your user groups are applied to the product you try to create.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_products_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: ProductsEmbeddedItemsInnerAllOf1
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_products" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['body']:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'code', 'message', '_links'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/rest/v1/products', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def post_proposal(self, code : Annotated[StrictStr, Field(..., description="Code of the resource")], **kwargs) -> None:  # noqa: E501
        """Submit a draft for approval  # noqa: E501

        This endpoint allows you to submit a draft for approval.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_proposal(code, async_req=True)
        >>> result = thread.get()

        :param code: Code of the resource (required)
        :type code: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.post_proposal_with_http_info(code, **kwargs)  # noqa: E501

    @validate_arguments
    def post_proposal_with_http_info(self, code : Annotated[StrictStr, Field(..., description="Code of the resource")], **kwargs):  # noqa: E501
        """Submit a draft for approval  # noqa: E501

        This endpoint allows you to submit a draft for approval.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_proposal_with_http_info(code, async_req=True)
        >>> result = thread.get()

        :param code: Code of the resource (required)
        :type code: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'code'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_proposal" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['code']:
            _path_params['code'] = _params['code']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'code', 'message', '_links'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/rest/v1/products/{code}/proposal', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
